module spi_master#(
    parameter NBITS = 24,
    parameter NCLKDIVBITS = 8,
    parameter NCSBITS = 3
    )(
    /* Control Inputs */
    // Clock domain on which data is presented.
    // SCLK is generated by dividing this by 2^NCSBITS
    input clk,
    input [NCSBITS - 1 : 0] cs_n_in, // Chip select in
    input [NBITS - 1 : 0] din,       // Data to be serialized and sent
    input trigger,                   // Trigger a new send on posedge
    input ack,                       // acknowledge last received data 
    output [NBITS - 1 : 0] dout,     // Data received and deserialized
    output dvld,                     // Go high on new data
    
    /* spi signals */
    output [NCSBITS - 1 : 0] cs_n,
    output sclk,
    output mosi,
    input miso
    );

    reg [NCSBITS - 1 : 0] cs_n_reg = {NCSBITS{1'b1}};
    reg sclk_reg = 1'b0;
    reg mosi_reg = 1'b0;
    reg [NBITS - 1 : 0] dout_reg;
    reg dvld_reg;
    assign cs_n = cs_n_reg;
    assign sclk = sclk_reg;
    assign mosi = mosi_reg;
    assign dout = dout_reg;
    assign dvld = dvld_reg;

    // State machine states
    localparam IDLE = 3'd0;
    localparam WAIT = 3'd1;
    localparam START = 3'd2;
    localparam CLK_RISE = 3'd3;
    localparam CLK_FALL = 3'd4;
    localparam END = 3'd5;
    localparam AWAIT_ACK = 3'd6;
    reg [2:0] state = IDLE;

    // Generate SPI clock
    reg [NCLKDIVBITS : 0] sclk_ctr = 0;
    wire sclk_int = sclk_ctr[NCLKDIVBITS];
    reg sclk_intR;
    wire sclk_posedge = sclk_int & ~sclk_intR;
    wire sclk_negedge = sclk_intR & ~sclk_int;
    always @(posedge clk) begin
      sclk_ctr <= sclk_ctr + 1'b1;
      sclk_intR <= sclk_int;
    end

    reg triggerR = 0;
    always @(posedge clk) begin
      triggerR <= trigger;
    end

    reg [NCSBITS - 1 : 0] cs_n_int;
    reg [NBITS - 1 : 0] din_int;
    reg [15:0] bit_cnt;
    
    always @(posedge clk) begin
      case (state)
        IDLE: begin
          bit_cnt <= 0;
          state <= IDLE;
          if (trigger & ~triggerR) begin // posedge
            cs_n_int <= cs_n_in;
            din_int <= din;
            state <= WAIT;
          end
        end
        WAIT: begin
          if (sclk_negedge) begin
            state <= START;
          end
        end
        START: begin
          if (sclk_posedge) begin
            state <= CLK_RISE;
            bit_cnt <= 1'b1;
            dout_reg <= {dout_reg[NBITS - 2 : 0], miso};
          end
        end
        CLK_RISE: begin
          if (sclk_negedge) begin
            if (bit_cnt == NBITS) begin
              state <= END;
            end else begin
              state <= CLK_FALL;
              bit_cnt <= bit_cnt + 1'b1;
              din_int <= {din_int[NBITS - 2 : 0], 1'b0};
            end
          end
        end
        CLK_FALL: begin
          if (sclk_posedge) begin
            dout_reg <= {dout_reg[NBITS - 2 : 0], miso};
            state <= CLK_RISE;
          end
        end
        END: begin
          if (sclk_posedge) begin
            state <= AWAIT_ACK;
          end
        end
        AWAIT_ACK: begin
          if (ack) begin
            state <= IDLE;
          end
        end
        default: begin
          state <= IDLE;
        end
      endcase
    end

    always @(*) begin
      case (state)
        IDLE: begin
          cs_n_reg <= {NCSBITS{1'b1}};
          sclk_reg <= 1'b0;
          mosi_reg <= 1'b0;
          dvld_reg <= 1'b0;
        end
        START: begin
          sclk_reg <= 1'b0;
          cs_n_reg <= cs_n_int;
          mosi_reg <= din_int[NBITS-1];
          dvld_reg <= 1'b0;
        end
        CLK_RISE: begin
          sclk_reg <= 1'b1;
          cs_n_reg <= cs_n_int;
          mosi_reg <= din_int[NBITS-1];
          dvld_reg <= 1'b0;
        end
        CLK_FALL: begin
          sclk_reg <= 1'b0;
          cs_n_reg <= cs_n_int;
          mosi_reg <= din_int[NBITS-1];
          dvld_reg <= 1'b0;
        end
        END: begin
          sclk_reg <= 1'b1;
          cs_n_reg <= {NCSBITS{1'b1}};
          mosi_reg <= din_int[NBITS-1];
          dvld_reg <= 1'b0;
        end
        AWAIT_ACK: begin
          cs_n_reg <= {NCSBITS{1'b1}};
          sclk_reg <= 1'b1;
          mosi_reg <= 1'b0;
          dvld_reg <= 1'b1;
        end
        default: begin
          cs_n_reg <= {NCSBITS{1'b1}};
          sclk_reg <= 1'b0;
          mosi_reg <= 1'b0;
          dvld_reg <= 1'b0;
        end
      endcase
    end
endmodule
